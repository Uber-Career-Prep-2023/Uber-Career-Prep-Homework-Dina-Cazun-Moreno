Question 1: Build an Adjacency List/Set Representation of a Graph
Given an array of pairs of values representing edges in an unweighted graph, create the equivalent adjacency list/set representation (a map from element to a list or set of elements). 
Pairs represent directed edges: (A, B) means there is an edge from A to B. If the pair (B, A) is also provided then there is an undirected edge between A and B. 
For simplicity, you may assume that each node of the graph stores an integer rather than a generic data type and that the elements are distinct. 
Implement a basic DFS and BFS searching for a target value and a topological sort (using either DFS or Kahnâ€™s algorithm).

Question 2: Build a Heap
Write a min heap class according to the following API using an array as the underlying data structure. 
(A max heap has the same implementation; you simply need to flip the direction of the comparators.) 
For simplicity, you can assume that the heap holds integers rather than generic comparables.

Question 3: Build a Priority Queue
A priority queue functions like a queue except that elements are removed in order of priority rather than insertion. 
This is typically implemented as a max heap that stores pairs of elements and numeric weights, with the weights used as the values in the heap. 
Implement a priority queue according to the following API using a heap as the underlying data structure. 
For simplicity, you can assume the priority queue stores string elements with integer priorities. 
Start by copy-pasting your heap implementation from question 2 and making modifications.
